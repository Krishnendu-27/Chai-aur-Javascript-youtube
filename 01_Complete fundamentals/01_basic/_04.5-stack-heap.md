---
## 📅 Wednesday, October 08, 2025, 7:18 PM IST

# 🧠 JavaScript Stack & Heap Memory

Understanding how JavaScript manages memory is crucial for avoiding bugs and writing efficient code.
---

## 📚 Memory Types Overview

| Memory Type  | Data Stored              | Access Method    | Behavior            |
| ------------ | ------------------------ | ---------------- | ------------------- |
| **🗂️ Stack** | Primitives               | By **Value**     | **Copy** of data    |
| **🏗️ Heap**  | Objects/Arrays/Functions | By **Reference** | **Pointer** to data |

---

## 🗂️ Stack Memory (Primitives)

**Stack stores**: `string`, `number`, `boolean`, `null`, `undefined`, `Symbol`, `bigint`

### 📋 Copy Behavior Example

```javascript
// Primitive assignment creates a COPY
let name1 = "K";
let title = name1; // 'title' gets a COPY of 'K'
title = "C"; // Only 'title' changes

console.log(name1); // Output: 'K' (unchanged)
console.log(title); // Output: 'C' (changed)
```

**🔍 What Happens**:

- `name1` stores `'K'` in stack
- `title` gets its **own copy** of `'K'`
- Changing `title` doesn't affect `name1`

---

## 🏗️ Heap Memory (Non-Primitives)

**Heap stores**: Objects `{}`, Arrays `[]`, Functions `function(){}`

### 🔗 Reference Behavior Example

```javascript
// Object assignment creates a REFERENCE
let user1 = { name: "H" };
let user2 = user1; // Both point to SAME object in heap
user2.name = "A"; // Changes the original object

console.log(user1.name); // Output: 'A' (changed!)
console.log(user2.name); // Output: 'A' (same object)
```

**🔍 What Happens**:

- `user1` stores **reference** to object in heap
- `user2` gets the **same reference** (not a copy)
- Both variables point to the **same memory location**

---

## 🎯 Memory Visualization

### Stack Memory (Copy)

```
Stack Memory:
┌─────────┬─────┐
│  name1  │ 'K' │ ← Original value
├─────────┼─────┤
│  title  │ 'C' │ ← Independent copy
└─────────┴─────┘
```

### Heap Memory (Reference)

```
Stack Memory:        Heap Memory:
┌─────────┬─────┐    ┌─────────────┐
│  user1  │ ref1│───►│{name: 'A'}  │
├─────────┼─────┤    │             │
│  user2  │ ref1│───►│             │
└─────────┴─────┘    └─────────────┘
    Both point to same object!
```

---

![alt text](/imge%20for%20notes%20/image2.png)

## ⚠️ Common Pitfalls & Solutions

### 🚨 Problem: Unintended Object Mutation

```javascript
let originalUser = { name: "John", age: 25 };
let modifiedUser = originalUser; // ❌ Reference copy
modifiedUser.age = 30;

console.log(originalUser.age); // 30 (Oops! Original changed)
```

### ✅ Solution: Create True Copies

**Shallow Copy** (for simple objects):

```javascript
let originalUser = { name: "John", age: 25 };

// Method 1: Spread operator
let copy1 = { ...originalUser };

// Method 2: Object.assign()
let copy2 = Object.assign({}, originalUser);

copy1.age = 30;
console.log(originalUser.age); // 25 (Original unchanged ✅)
```

**Deep Copy** (for nested objects):

```javascript
let user = {
  name: "John",
  address: { city: "NYC", zip: 10001 },
};

// JSON method (simple but limited)
let deepCopy = JSON.parse(JSON.stringify(user));

// Using structuredClone() (modern browsers)
let deepCopy2 = structuredClone(user);
```

---

## 🔍 Practical Examples

### 📊 Array

```javascript
let arr1 = [1, 2, 3];
let arr2 = arr1; // Reference copy
arr2.push(4);

console.log(arr1); // [1, 2, 3, 4] (Original changed!)

// To avoid this:
let arr3 = [...arr1]; // Spread creates new array
let arr4 = arr1.slice(); // slice() also creates copy
```

### 🔧 Function Parameters

```javascript
function updateUser(user) {
  user.name = "Updated"; // Modifies original object!
}

let myUser = { name: "Original" };
updateUser(myUser);
console.log(myUser.name); // 'Updated' (Original changed)

// To avoid mutation:
function updateUserSafely(user) {
  let userCopy = { ...user };
  userCopy.name = "Updated";
  return userCopy;
}
```

---

## 📋 Quick Reference Guide

### ✅ When to Use Stack (Primitives)

- Simple values that don't need to be shared
- Counters, flags, simple calculations
- Immutable data

### ✅ When to Use Heap (Objects)

- Complex data structures
- Data that needs to be shared between functions
- When you need reference semantics

### 🛡️ Best Practices

1. **🔄 Copy objects** when you need independence
2. **📝 Use const** for object references to prevent reassignment
3. **🧪 Test mutations** - always verify if changes affect originals
4. **📚 Understand libraries** - some modify originals, others return copies

---

## ✨ Key Takeaways

- **🗂️ Stack Memory**: Primitives get **copied** → independent values
- **🏗️ Heap Memory**: Objects get **referenced** → shared memory location
- **⚠️ Mutation Risk**: Changing object properties affects all references
- **✅ Safe Copying**: Use spread `{...obj}`, `Object.assign()`, or `JSON` methods
- **🎯 Memory Efficiency**: References save memory but require careful handling

---


