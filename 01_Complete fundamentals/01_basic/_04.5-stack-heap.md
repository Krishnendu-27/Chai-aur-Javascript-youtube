---
## ğŸ“… Wednesday, October 08, 2025, 7:18 PM IST

# ğŸ§  JavaScript Stack & Heap Memory

Understanding how JavaScript manages memory is crucial for avoiding bugs and writing efficient code.
---

## ğŸ“š Memory Types Overview

| Memory Type  | Data Stored              | Access Method    | Behavior            |
| ------------ | ------------------------ | ---------------- | ------------------- |
| **ğŸ—‚ï¸ Stack** | Primitives               | By **Value**     | **Copy** of data    |
| **ğŸ—ï¸ Heap**  | Objects/Arrays/Functions | By **Reference** | **Pointer** to data |

---

## ğŸ—‚ï¸ Stack Memory (Primitives)

**Stack stores**: `string`, `number`, `boolean`, `null`, `undefined`, `Symbol`, `bigint`

### ğŸ“‹ Copy Behavior Example

```javascript
// Primitive assignment creates a COPY
let name1 = "K";
let title = name1; // 'title' gets a COPY of 'K'
title = "C"; // Only 'title' changes

console.log(name1); // Output: 'K' (unchanged)
console.log(title); // Output: 'C' (changed)
```

**ğŸ” What Happens**:

- `name1` stores `'K'` in stack
- `title` gets its **own copy** of `'K'`
- Changing `title` doesn't affect `name1`

---

## ğŸ—ï¸ Heap Memory (Non-Primitives)

**Heap stores**: Objects `{}`, Arrays `[]`, Functions `function(){}`

### ğŸ”— Reference Behavior Example

```javascript
// Object assignment creates a REFERENCE
let user1 = { name: "H" };
let user2 = user1; // Both point to SAME object in heap
user2.name = "A"; // Changes the original object

console.log(user1.name); // Output: 'A' (changed!)
console.log(user2.name); // Output: 'A' (same object)
```

**ğŸ” What Happens**:

- `user1` stores **reference** to object in heap
- `user2` gets the **same reference** (not a copy)
- Both variables point to the **same memory location**

---

## ğŸ¯ Memory Visualization

### Stack Memory (Copy)

```
Stack Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚  name1  â”‚ 'K' â”‚ â† Original value
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚  title  â”‚ 'C' â”‚ â† Independent copy
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
```

### Heap Memory (Reference)

```
Stack Memory:        Heap Memory:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  user1  â”‚ ref1â”‚â”€â”€â”€â–ºâ”‚{name: 'A'}  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤    â”‚             â”‚
â”‚  user2  â”‚ ref1â”‚â”€â”€â”€â–ºâ”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    Both point to same object!
```

---

![alt text](/imge%20for%20notes%20/image2.png)

## âš ï¸ Common Pitfalls & Solutions

### ğŸš¨ Problem: Unintended Object Mutation

```javascript
let originalUser = { name: "John", age: 25 };
let modifiedUser = originalUser; // âŒ Reference copy
modifiedUser.age = 30;

console.log(originalUser.age); // 30 (Oops! Original changed)
```

### âœ… Solution: Create True Copies

**Shallow Copy** (for simple objects):

```javascript
let originalUser = { name: "John", age: 25 };

// Method 1: Spread operator
let copy1 = { ...originalUser };

// Method 2: Object.assign()
let copy2 = Object.assign({}, originalUser);

copy1.age = 30;
console.log(originalUser.age); // 25 (Original unchanged âœ…)
```

**Deep Copy** (for nested objects):

```javascript
let user = {
  name: "John",
  address: { city: "NYC", zip: 10001 },
};

// JSON method (simple but limited)
let deepCopy = JSON.parse(JSON.stringify(user));

// Using structuredClone() (modern browsers)
let deepCopy2 = structuredClone(user);
```

---

## ğŸ” Practical Examples

### ğŸ“Š Array

```javascript
let arr1 = [1, 2, 3];
let arr2 = arr1; // Reference copy
arr2.push(4);

console.log(arr1); // [1, 2, 3, 4] (Original changed!)

// To avoid this:
let arr3 = [...arr1]; // Spread creates new array
let arr4 = arr1.slice(); // slice() also creates copy
```

### ğŸ”§ Function Parameters

```javascript
function updateUser(user) {
  user.name = "Updated"; // Modifies original object!
}

let myUser = { name: "Original" };
updateUser(myUser);
console.log(myUser.name); // 'Updated' (Original changed)

// To avoid mutation:
function updateUserSafely(user) {
  let userCopy = { ...user };
  userCopy.name = "Updated";
  return userCopy;
}
```

---

## ğŸ“‹ Quick Reference Guide

### âœ… When to Use Stack (Primitives)

- Simple values that don't need to be shared
- Counters, flags, simple calculations
- Immutable data

### âœ… When to Use Heap (Objects)

- Complex data structures
- Data that needs to be shared between functions
- When you need reference semantics

### ğŸ›¡ï¸ Best Practices

1. **ğŸ”„ Copy objects** when you need independence
2. **ğŸ“ Use const** for object references to prevent reassignment
3. **ğŸ§ª Test mutations** - always verify if changes affect originals
4. **ğŸ“š Understand libraries** - some modify originals, others return copies

---

## âœ¨ Key Takeaways

- **ğŸ—‚ï¸ Stack Memory**: Primitives get **copied** â†’ independent values
- **ğŸ—ï¸ Heap Memory**: Objects get **referenced** â†’ shared memory location
- **âš ï¸ Mutation Risk**: Changing object properties affects all references
- **âœ… Safe Copying**: Use spread `{...obj}`, `Object.assign()`, or `JSON` methods
- **ğŸ¯ Memory Efficiency**: References save memory but require careful handling

---


